<!DOCTYPE html>
<!-- 
MIT License
Copyright (c) 2024  Oleksandr Lavrynenko  la2017aug@gmail.com
Permission is granted to use, copy, modify, and distribute this software under the MIT License.
See the LICENSE file for full terms.
-->
<html lang="en" content="notranslate">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="google" content="notranslate">
    <title>Menu</title>
    <style>
        .node-container {
            margin-left: 41px; 
        }
        .node-button {
            margin-right: 10px; 
            min-width: 100px; 
            border: none;
            border-radius: 5px;
            margin-top: 10px; 
            padding: 8px 20px;
        }
        .toggle-button {
            text-align: center;
            width: 31px; 
            background-color: #007BFF;
            color: white;
            border: none;
            border-radius: 5px;
            margin-right: 10px; 
            padding: 8px;
        }
        .toggle-button:hover, .node-button[n-type="list"]:hover {
            background-color: #0056b3;
        }
        .node-button[n-type="list"] {
            background-color: #007BFF;
            color: white;
        }
        .node-button[n-type="text"] {
            background-color: #006400;
            color: #FEF;
        }
        .node-button[n-type="picture"] {
            background-color: #FFD700;
            color: #000;
        }
        .node-button[n-type="test"] {
            background-color: #DC143C;
            color: #FEF;
        }
        .node-button[n-type="question"] {
            background-color: #FFA500;
            color: #FEF;
        }
        .selected-button {
            box-shadow: inset 0 0 0 3px red; 
        }
        .node-button[n-type="other"] {
            background: linear-gradient(90deg, #ff6b6b, #f06595, #ff6b6b); 
            background-size: 200% 200%;
            color: white;
            padding: 8px 20px;
            border: none;
            border-radius: 5px;
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }
        .node-button[n-type="other"]::before {
            content: '';
            position: absolute;
            top: 0;
            left: -150%; 
            width: 200%; 
            height: 100%;
            background: rgba(255, 255, 255, 0.6); 
            transform: skewX(-20deg); 
            animation: shine 2.5s ease infinite; 
        }
        @keyframes shine {
            0% {left: -150%;}
            50% {left: 100%;}
            100% {left: 150%;}
        }
    </style>
</head>
<body>
    <header>
        <img src="images/logo1.png" class="logo" style="width: 100px; height: auto">
    </header>
    <div id="nodes-container"></div>
    <footer>
        <p>&copy; 2024 Oleksandr Lavrynenko. This project is licensed under the <a href="./LICENSE.md">MIT License</a>.</p>
        <p><a href="./about.html">About the program / Help</a></p>
    </footer>
    <script>
        function getURLParameter(name) {
            return new URLSearchParams(window.location.search).get(name);
        }
        const dataParam = getURLParameter('data');
        const scriptPath = dataParam ? `${dataParam}.js` : 'main.js';
        const script = document.createElement('script');
        script.src = scriptPath;
        script.onload = function() {
            initPage();  
        };
        script.onerror = function() {
        };
        document.body.appendChild(script);
        function initPage() {
            if (typeof nodesData !== 'undefined') {
                const lines = nodesData.trim().split('\n');
                const Nodes = [];
                let nodeTop = null;
                lines.forEach(line => {
                    let parts = line.split('\t');
                    let type = (parts[0] || '').trim();
                    let data = (parts[1] || '').trim();
                    let text = (parts[2] || data).trim();
                    if (parts[0].startsWith('  ')) {
                        let nodeSub = new Node(type, data, text);
                        nodeTop.children.push(nodeSub);
                    } else {
                        nodeTop = new Node(type, data, text);
                        Nodes.push(nodeTop);
                    }
                });
                function createNodeElement(node, isChild = false) {
                    const container = document.createElement('div');
                    container.className = isChild ? 'node-container' : '';
                    const button = document.createElement('button');
                    button.className = 'node-button';
                    button.textContent = node.text;
                    button.setAttribute('n-type', node.type);
                    button.setAttribute('n-data', node.data);
                    button.addEventListener('click', () => {
                        if (lastSelectedButton) {
                            lastSelectedButton.classList.remove('selected-button');
                        }
                        button.classList.add('selected-button');
                        lastSelectedButton = button;
                        const type = button.getAttribute('n-type');
                        const data = button.getAttribute('n-data');
                        if (type === 'list') {
                            window.open('list.html?number=' + data, '_blank');
                        } else if (type === 'text') {
                            window.open('text.html?number=' + data, '_blank');
                        } else if (type === 'picture') {
                            window.open('picture.html?number=' + data, '_blank');
                        } else if (type === 'test') {
                            window.open('test.html?number=' + data, '_blank');
                        } else if (type === 'question') {
                            window.open('question.html', '_blank');
                        } else if (type === 'index') {
                            window.open('index.html?data=' + data, '_self');
                        } else if (type === 'help') {
                            window.open('about.html', '_self');
                        }
                    });
                    const label = document.createElement('span');
                    label.textContent = '   ';
                    container.appendChild(button);
                    container.appendChild(label);
                    if (node.children.length > 0) {
                        const toggleButton = document.createElement('button');
                        toggleButton.textContent = '+';
                        toggleButton.className = 'toggle-button';
                        container.insertBefore(toggleButton, button);
                        const childrenContainer = document.createElement('div');
                        childrenContainer.style.display = 'none';
                        node.children.forEach(child => {
                            const childElement = createNodeElement(child, true);
                            childrenContainer.appendChild(childElement);
                        });
                        toggleButton.addEventListener('click', () => {
                            if (childrenContainer.style.display === 'none') {
                                childrenContainer.style.display = 'block';
                                toggleButton.textContent = '-';
                            } else {
                                childrenContainer.style.display = 'none';
                                toggleButton.textContent = '+';
                            }
                        });
                        container.appendChild(childrenContainer);
                    }
                    return container;
                }
                const nodesContainer = document.getElementById('nodes-container');
                Nodes.forEach(node => {
                    const nodeElement = createNodeElement(node);
                    nodesContainer.appendChild(nodeElement);
                });
            } else {
            }
        }
        class Node {
            constructor(type, data, text, children = []) {
                this.type = type;
                this.data = data;
                this.text = text;
                this.children = children;
            }
        }
        var lastSelectedButton = null;
    </script>
</body>
</html>
